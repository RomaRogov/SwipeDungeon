// Generated by Haxe 3.4.0
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Main = function() {
	this._stage = new PIXI.Container();
	Main.renderer = PIXI.autoDetectRenderer(window.innerWidth?window.innerWidth:window.document.documentElement.clientWidth,window.innerHeight?window.innerHeight:window.document.documentElement.clientHeight,{ backgroundColor : 0, roundPixels : false});
	window.document.body.appendChild(Main.renderer.view);
	window.requestAnimationFrame($bind(this,this.onFrame));
	window.onresize = $bind(this,this.onResize);
	utils_FrameDispatcher.init();
	utils_Keyboard.init();
	utils_GestureRecognizer.init();
	var level = new game_Level();
	this._stage.addChild(level);
};
Main.main = function() {
	new Main();
};
Main.prototype = {
	onFrame: function() {
		window.requestAnimationFrame($bind(this,this.onFrame));
		Main.renderer.render(this._stage);
	}
	,onResize: function() {
		var width = window.innerWidth?window.innerWidth:window.document.documentElement.clientWidth;
		var height = window.innerHeight?window.innerHeight:window.document.documentElement.clientHeight;
		Main.renderer.resize(width,height);
	}
};
var game_BinaryNode = function(x,y,width,height,root,isLeft) {
	this._roomSize = 10;
	this._root = root;
	this._isLeft = isLeft;
	this._x = x;
	this._y = y;
	this._w = width;
	this._h = height;
	var splittingHor = Math.random() > .5;
	var randomFactor = .3 + Math.random() * .3;
	if(splittingHor) {
		if(width >= this._roomSize * 2) {
			var pos = this._roomSize + Math.floor(randomFactor * (width - this._roomSize * 2));
			this.leftNode = new game_BinaryNode(x,y,pos,height,this,true);
			this.rightNode = new game_BinaryNode(x + pos,y,width - pos,height,this,false);
			this.hasChildren = true;
			return;
		}
	} else if(height >= this._roomSize * 2) {
		var pos1 = this._roomSize + Math.floor(randomFactor * (height - this._roomSize * 2));
		this.leftNode = new game_BinaryNode(x,y,width,pos1,this,true);
		this.rightNode = new game_BinaryNode(x,y + pos1,width,height - pos1,this,false);
		this.hasChildren = true;
		return;
	}
	this.hasChildren = false;
	this._roomX = 1 + Math.floor(Math.random() * this._w / 2);
	this._roomY = 1 + Math.floor(Math.random() * this._h / 2);
	this._roomW = Math.floor(Math.max((.6 + Math.random() * .4) * (this._w - this._roomX),this._roomSize / 2 - 2));
	this._roomH = Math.floor(Math.max((.6 + Math.random() * .4) * (this._h - this._roomY),this._roomSize / 2 - 2));
};
game_BinaryNode.prototype = {
	drawRect: function(where) {
		if(this.hasChildren) {
			this.leftNode.drawRect(where);
			this.rightNode.drawRect(where);
			return;
		}
		where.drawRect(this._x * 32,this._y * 32,this._w * 32,this._h * 32);
		where.beginFill(16777215,.6);
		where.drawRect((this._x + this._roomX) * 32,(this._y + this._roomY) * 32,this._roomW * 32,this._roomH * 32);
		where.endFill();
		if(this._isLeft) {
			where.moveTo(this.getCenterX() * 32,this.getCenterY() * 32);
			where.lineTo(this._root.rightNode.getCenterX() * 32,this._root.rightNode.getCenterY() * 32);
		}
	}
	,getCenterX: function() {
		return this._x + this._roomX + this._roomW / 2;
	}
	,getCenterY: function() {
		return this._y + this._roomY + this._roomH / 2;
	}
};
var game_Level = function() {
	PIXI.Container.call(this);
	var floorTex = PIXI.Texture.fromImage("assets/floor.png");
	var tiles = new PIXI.Container();
	var _g = 0;
	while(_g < 10) {
		var i = _g++;
		var _g1 = 0;
		while(_g1 < 10) {
			var tile = new PIXI.Sprite(floorTex);
			tile.x = _g1++ * 32;
			tile.y = i * 32;
			tiles.addChild(tile);
		}
	}
	this._player = new game_Player();
	this.addChild(this._player);
	utils_FrameDispatcher.addListener(this,$bind(this,this.onFrame));
	var debugGraph = new PIXI.Graphics();
	debugGraph.lineStyle(1,16777215,.3);
	this.addChild(debugGraph);
	new game_BinaryNode(0,0,100,100,null,true).drawRect(debugGraph);
};
game_Level.__super__ = PIXI.Container;
game_Level.prototype = $extend(PIXI.Container.prototype,{
	onFrame: function(delta) {
		this.x = Main.renderer.width / 2 - this._player.x;
		this.y = Main.renderer.height / 2 - this._player.y;
	}
});
var game_Player = function() {
	this._stepTime = 5;
	var firstFrameTex = PIXI.Texture.fromImage("assets/player_frame1.png");
	firstFrameTex.baseTexture.scaleMode = 1;
	PIXI.Sprite.call(this,firstFrameTex);
	utils_FrameDispatcher.addListener(this,$bind(this,this.onFrame));
	this.scale.set(2);
	this.anchor.set(.5);
	this.position.set(16);
	this._targetPos = new PIXI.Point(this.x,this.y);
	utils_GestureRecognizer.addListener($bind(this,this.onSwipe));
	this._timeSinceLastMove = 0;
};
game_Player.__super__ = PIXI.Sprite;
game_Player.prototype = $extend(PIXI.Sprite.prototype,{
	onFrame: function(delta) {
		this.position.x += (this._targetPos.x - this.position.x) * .3;
		this.position.y += (this._targetPos.y - this.position.y) * .3;
		this._timeSinceLastMove += delta;
	}
	,onSwipe: function(direction) {
		if(this._timeSinceLastMove < this._stepTime) {
			return;
		}
		switch(direction) {
		case "down":
			this._targetPos.y -= 32;
			break;
		case "left":
			this._targetPos.x += 32;
			break;
		case "right":
			this._targetPos.x -= 32;
			break;
		case "up":
			this._targetPos.y += 32;
			break;
		}
		this._timeSinceLastMove = 0;
	}
});
var haxe_IMap = function() { };
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
};
var utils_FrameDispatcher = function() {
	this._listeners = new haxe_ds_ObjectMap();
	this._ticker = new PIXI.ticker.Ticker();
	this._ticker.autoStart = true;
	this._ticker.add($bind(this,this.update));
};
utils_FrameDispatcher.init = function() {
	utils_FrameDispatcher._instance = new utils_FrameDispatcher();
};
utils_FrameDispatcher.addListener = function(listener,frameFunc) {
	utils_FrameDispatcher._instance._listeners.set(listener,frameFunc);
};
utils_FrameDispatcher.prototype = {
	update: function() {
		var listener = this._listeners.keys();
		while(listener.hasNext()) {
			var listener1 = listener.next();
			if(listener1.worldVisible) {
				this._listeners.h[listener1.__id__](this._ticker.deltaTime);
			}
		}
	}
};
var utils_GestureRecognizer = function() {
	this._actionDistance = 32;
	this._minDistance = .1;
	this._allowedDeviation = .2;
	this._manager = Main.renderer.plugins.interaction;
	this._manager.on("pointerdown",$bind(this,this.onDown));
	this._manager.on("pointermove",$bind(this,this.onMove));
	this._manager.on("pointerup",$bind(this,this.onUp));
	this._manager.on("pointerout",$bind(this,this.onOut));
	this._listeners = [];
};
utils_GestureRecognizer.init = function() {
	utils_GestureRecognizer._instance = new utils_GestureRecognizer();
};
utils_GestureRecognizer.addListener = function(func) {
	utils_GestureRecognizer._instance._listeners.push(func);
};
utils_GestureRecognizer.sign = function(x) {
	if(x > 0) {
		return 1;
	} else if(x < 0) {
		return -1;
	} else {
		return 0;
	}
};
utils_GestureRecognizer.prototype = {
	onDown: function(e) {
		this._start = e.data.global.clone();
		this._maxDeviation = new PIXI.Point();
	}
	,onMove: function(e) {
		if(this._start == null) {
			return;
		}
		this._maxDeviation.x = Math.max(Math.abs(e.data.global.x - this._start.x),this._maxDeviation.x);
		this._maxDeviation.y = Math.max(Math.abs(e.data.global.y - this._start.y),this._maxDeviation.y);
		if(Math.sqrt(this._maxDeviation.x * this._maxDeviation.x + this._maxDeviation.y * this._maxDeviation.y) < this._actionDistance) {
			return;
		}
		this.checkSwipe(e.data.global);
		this._start = e.data.global.clone();
		this._maxDeviation = new PIXI.Point();
	}
	,onUp: function(e) {
		if(this._start == null || this._maxDeviation == null) {
			return;
		}
		this.dispatch("end");
		this._start = null;
		this._maxDeviation = new PIXI.Point();
	}
	,onOut: function() {
		this._start = null;
		this._maxDeviation = null;
	}
	,checkSwipe: function(currentPos) {
		if(Math.min(this._maxDeviation.x,this._maxDeviation.y) / Math.max(this._maxDeviation.x,this._maxDeviation.y) > this._allowedDeviation) {
			return;
		}
		var delta = new PIXI.Point(currentPos.x - this._start.x,currentPos.y - this._start.y);
		if(this._maxDeviation.x > this._maxDeviation.y) {
			if(delta.x > 0) {
				this.dispatch("right");
			} else {
				this.dispatch("left");
			}
		} else if(delta.y > 0) {
			this.dispatch("down");
		} else {
			this.dispatch("up");
		}
	}
	,dispatch: function(side) {
		var _g = 0;
		var _g1 = this._listeners;
		while(_g < _g1.length) {
			var listener = _g1[_g];
			++_g;
			listener(side);
		}
	}
};
var utils_Keyboard = function() {
	this._pressedKeys = [];
	window.document.addEventListener("keydown",$bind(this,this.onKeyDown));
	window.document.addEventListener("keyup",$bind(this,this.onKeyUp));
};
utils_Keyboard.init = function() {
	utils_Keyboard._instance = new utils_Keyboard();
};
utils_Keyboard.keyPressed = function(which) {
	return utils_Keyboard._instance._pressedKeys.indexOf(which) != -1;
};
utils_Keyboard.prototype = {
	onKeyDown: function(e) {
		if(this._pressedKeys.indexOf(e.which) == -1) {
			this._pressedKeys.push(e.which);
		}
		utils_Keyboard.currentKey = e.which;
	}
	,onKeyUp: function(e) {
		HxOverrides.remove(this._pressedKeys,e.which);
		utils_Keyboard.currentKey = null;
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
haxe_ds_ObjectMap.count = 0;
Main.main();
})();
